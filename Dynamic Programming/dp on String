///// 

///// Minimum Insertion Steps to Make a String Palindrome
class Solution {
    public int helper(String s1 , String s2,int i,int j,Integer[][] dp){
        if(i==s1.length() || j == s2.length()){
            return 0;
        }
        if(dp[i][j] != null){
            return dp[i][j];
        }
        if(s1.charAt(i)==s2.charAt(j)){
            return 1+ helper(s1,s2,i+1,j+1,dp);
        }
        int pick1 = helper(s1,s2,i+1,j,dp);
        int pick2 = helper(s1,s2,i,j+1,dp);
        dp[i][j] = Math.max(pick1,pick2);
        return dp[i][j];
    }
    public int minInsertions(String s) {
        StringBuilder sb = new StringBuilder(s);
        Integer dp[][] = new Integer[s.length()][s.length()];
        int n = s.length();
    sb.reverse();
    String reversed = sb.toString();
    return n-helper(s,reversed,0,0,dp);
    }
}

///// Tabulation Approach
class Solution {
    public int minInsertions(String s) {
        int n = s.length();
        String rev = new StringBuilder(s).reverse().toString();
        int dp[][] = new int[n+1][n+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(s.charAt(i-1)==rev.charAt(j-1)){
                    dp[i][j]=1+dp[i-1][j-1];
                }
                else{
                    dp[i][j]= Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        int k = dp[n][n];
        return n-k;
    }
}


///////   . Delete Operation for Two Strings
class Solution {
    public int helper(String s1,String s2,int i,int j,Integer[][] dp){
        if(i==s1.length() || j==s2.length()) return 0;
        if(dp[i][j]!=null) return dp[i][j];
        if(s1.charAt(i)==s2.charAt(j)) return 1+helper(s1,s2,i+1,j+1,dp);
        int pick1 = helper(s1,s2,i+1,j,dp);
        int pick2 = helper(s1,s2,i,j+1,dp);
        dp[i][j]= Math.max(pick1,pick2);
        return dp[i][j];
    }
    public int minDistance(String word1, String word2) {
        int n = word1.length();
        int m = word2.length();
        Integer[][] dp = new Integer[word1.length()][word2.length()];
        int k = helper(word1,word2,0,0,dp);
        return (n-k)+(m-k);
    }
}


/// Tabulation Approach
class Solution {
    public int minDistance(String word1, String word2) {
        int n = word1.length();
        int m = word2.length();
        int dp[][] = new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[i][j]=1+dp[i-1][j-1];
                }
                else{
                    dp[i][j]= Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        int k = dp[n][m];
        return (n-k)+(m-k);
    }
}

///  Edit distance

class Solution {

    public int minDist(String word1, String word2, int i, int j,int[][] dp) {

        if (i == word1.length()) return word2.length() - j;
        if (j == word2.length()) return word1.length() - i;

        if (word1.charAt(i) == word2.charAt(j)) {
            return minDist(word1, word2, i + 1, j + 1,dp);
        }
        if(dp[i][j]!=-1) return dp[i][j];
        int insert = 1 + minDist(word1, word2, i, j + 1,dp);
        int delete = 1 + minDist(word1, word2, i + 1, j,dp);
        int replace = 1 + minDist(word1, word2, i + 1, j + 1,dp);
        dp[i][j]=Math.min(insert, Math.min(delete, replace));
        return dp[i][j];
    }

    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length()+1][word2.length()+1];
        int m = word1.length();
        int n = word2.length();
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                dp[i][j]=-1;
            }
        }
        return minDist(word1, word2, 0, 0,dp);
    }
}

